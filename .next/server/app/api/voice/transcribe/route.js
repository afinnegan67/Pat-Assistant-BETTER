"use strict";(()=>{var e={};e.id=650,e.ids=[650],e.modules={399:e=>{e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},517:e=>{e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},7130:(e,t,r)=>{r.r(t),r.d(t,{originalPathname:()=>v,patchFetch:()=>E,requestAsyncStorage:()=>j,routeModule:()=>y,serverHooks:()=>O,staticGenerationAsyncStorage:()=>k});var n={};r.r(n),r.d(n,{POST:()=>h,PUT:()=>_});var a=r(9303),o=r(8716),i=r(670),s=r(7070),c=r(9313),d=r(1931),l=r(5090);let u=`You are the transcript processor for Patrick's construction assistant. You analyze meeting transcripts and voice notes to extract:

1. TASKS: Action items, to-dos, things that need to be done
   - Include who mentioned it
   - Include any deadline mentioned
   - Include which project it relates to (if mentioned)

2. PROJECT KNOWLEDGE: Decisions made, information discussed, updates
   - Group by project
   - Keep chunks atomic (one fact/decision per chunk)
   - Include context for why the decision was made if available

3. NEW PROJECTS: Any new job sites or projects mentioned that don't exist

For each task extracted:
{
  "description": "string",
  "project_name": "string or null",
  "deadline": "string or null",
  "priority": "string or null"
}

For each knowledge chunk:
{
  "project_name": "string or null",
  "content": "string (the atomic fact or decision)"
}

For new projects:
{
  "name": "string",
  "client_name": "string or null",
  "project_type": "string or null"
}

Be thorough but precise. Don't invent information not in the transcript.

Respond with JSON:
{
  "tasks": [...],
  "knowledge": [...],
  "new_projects": [...]
}`;async function p(e,t){let r=(await (0,c.Yw)()).map(e=>e.name).join(", "),n=[{role:"system",content:u},{role:"user",content:`Existing projects: ${r||"None"}

Transcript:
${e}

Extract all tasks, knowledge, and new projects from this transcript.`}];try{let e=await (0,d.aN)(n);return{tasks:(e.tasks||[]).map(e=>({description:e.description||"",project_name:e.project_name||null,deadline:e.deadline||null,priority:function(e){if(!e)return null;let t=e.toLowerCase();return["low","medium","high","urgent"].includes(t)?t:null}(e.priority)})),knowledge:(e.knowledge||[]).map(e=>({project_name:e.project_name||null,content:e.content||""})),new_projects:(e.new_projects||[]).map(e=>({name:e.name||"",client_name:e.client_name||null,project_type:e.project_type||null}))}}catch(e){return console.error("Transcript processing error:",e),{tasks:[],knowledge:[],new_projects:[]}}}async function m(e,t){let r=0,n=0,a=0,o=new Map;for(let t of e.new_projects){if(!t.name)continue;let e=await (0,c.ib)(t.name);if(e){o.set(t.name.toLowerCase(),e.id);continue}let r=await (0,c.$L)({name:t.name,client_name:t.client_name,project_type:t.project_type,status:"future"});o.set(t.name.toLowerCase(),r.id),a++}for(let t of e.tasks){if(!t.description)continue;let e=null;if(t.project_name){let r=await (0,c.ib)(t.project_name);e=r?.id||o.get(t.project_name.toLowerCase())||null}await (0,c.vr)({description:t.description,project_id:e,deadline:t.deadline,priority:t.priority||"medium"}),r++}for(let r of e.knowledge){if(!r.content)continue;let e=null;if(r.project_name){let t=await (0,c.ib)(r.project_name);e=t?.id||o.get(r.project_name.toLowerCase())||null}let a=null;try{a=await (0,l.C6)(r.content)}catch(e){console.error("Failed to generate embedding:",e)}await (0,c.tR)({project_id:e,content:r.content,embedding:a,source_type:"meeting",source_id:t}),n++}return{tasksCreated:r,knowledgeAdded:n,projectsCreated:a}}var f=r(2126);let g=process.env.ELEVENLABS_API_KEY;async function w(e){let t=new FormData;t.append("audio",new Blob([new Uint8Array(e)]),"recording.webm"),t.append("model_id","scribe_v1");let r=await fetch("https://api.elevenlabs.io/v1/speech-to-text",{method:"POST",headers:{"xi-api-key":g},body:t});if(!r.ok){let e=await r.text();throw Error(`Transcription failed: ${e}`)}let n=await r.json(),a=n.text.split(/\s+/).length;return{text:n.text,duration:Math.round(a/150*60)}}async function h(e){try{let t=await e.formData(),r=t.get("audio"),n=t.get("duration");if(!r)return s.NextResponse.json({error:"No audio file provided"},{status:400});let a=await r.arrayBuffer(),o=Buffer.from(a),{text:i,duration:d}=await w(o),l=n?parseInt(n,10):d,u=await (0,c.ME)({raw_content:i,duration_seconds:l,source:"webapp"}),g=await p(i,"webapp"),h=function(e){let t=[];return(e.new_projects.length>0&&t.push(`New projects to create: ${e.new_projects.map(e=>e.name).join(", ")}`),e.tasks.length>0&&(t.push(`Tasks to create (${e.tasks.length}):`),e.tasks.slice(0,5).forEach(e=>{let r=e.project_name?` [${e.project_name}]`:"";t.push(`  - ${e.description}${r}`)}),e.tasks.length>5&&t.push(`  ... and ${e.tasks.length-5} more`)),e.knowledge.length>0&&t.push(`Knowledge chunks to store: ${e.knowledge.length}`),0===t.length)?"Nothing to extract from this transcript.":t.join("\n")}(g);if(l>1800)return await (0,f._b)(`Processed ${Math.round(l/60)} minute recording.

${h}

Reply "confirm" to save this data, or "cancel" to discard.`),s.NextResponse.json({success:!0,transcriptId:u.id,summary:h,needsConfirmation:!0,message:"Long recording - awaiting confirmation"});let _=await m(g,u.id);await (0,c.$3)(u.id,h);let y=`Processed recording: ${_.tasksCreated} tasks created, ${_.knowledgeAdded} knowledge chunks stored${_.projectsCreated>0?`, ${_.projectsCreated} new projects`:""}.`;return await (0,f._b)(y),s.NextResponse.json({success:!0,transcriptId:u.id,summary:h,needsConfirmation:!1,tasksCreated:_.tasksCreated,knowledgeAdded:_.knowledgeAdded,projectsCreated:_.projectsCreated})}catch(e){console.error("Transcription error:",e);try{await (0,f._b)("Your nephew Aidan failed to build me correctly. Blame him not me. (Voice transcription failed)")}catch(e){console.error("Failed to send error notification:",e)}return s.NextResponse.json({error:"Transcription failed",details:e.message},{status:500})}}async function _(e){try{let{transcriptId:t,action:r}=await e.json();if(!t)return s.NextResponse.json({error:"No transcript ID provided"},{status:400});if("cancel"===r)return await (0,f._b)("Recording discarded."),s.NextResponse.json({success:!0,message:"Transcript discarded"});if("confirm"===r)return await (0,f._b)("Recording data saved."),s.NextResponse.json({success:!0,message:"Transcript committed"});return s.NextResponse.json({error:"Invalid action"},{status:400})}catch(e){return console.error("Confirmation error:",e),s.NextResponse.json({error:"Confirmation failed",details:e.message},{status:500})}}let y=new a.AppRouteRouteModule({definition:{kind:o.x.APP_ROUTE,page:"/api/voice/transcribe/route",pathname:"/api/voice/transcribe",filename:"route",bundlePath:"app/api/voice/transcribe/route"},resolvedPagePath:"C:\\Users\\aidan\\OneDrive\\Documents\\Pats Assitant Improved\\app\\api\\voice\\transcribe\\route.ts",nextConfigOutput:"",userland:n}),{requestAsyncStorage:j,staticGenerationAsyncStorage:k,serverHooks:O}=y,v="/api/voice/transcribe/route";function E(){return(0,i.patchFetch)({serverHooks:O,staticGenerationAsyncStorage:k})}},5090:(e,t,r)=>{r.d(t,{C6:()=>o,pN:()=>c});var n=r(964);let a=process.env.OPENROUTER_API_KEY;async function o(e){let t=await fetch("https://openrouter.ai/api/v1/embeddings",{method:"POST",headers:{Authorization:`Bearer ${a}`,"Content-Type":"application/json","HTTP-Referer":process.env.APP_URL||"https://patricks-assistant.vercel.app","X-Title":"Patricks Assistant"},body:JSON.stringify({model:"openai/text-embedding-3-small",input:e})});if(!t.ok){let e=await t.text();throw Error(`Failed to generate embedding: ${e}`)}return(await t.json()).data[0].embedding}async function i(e,t=5,r){let a=n.O.rpc("match_knowledge",{query_embedding:e,match_threshold:.7,match_count:t}),{data:o,error:i}=await a;return i?(console.error("Vector search failed, falling back to simple query:",i.message),s(r,t)):o}async function s(e,t=5){let r=n.O.from("project_knowledge").select("*").order("created_at",{ascending:!1}).limit(t);e&&(r=r.eq("project_id",e));let{data:a,error:o}=await r;if(o)throw Error(`Failed to search knowledge: ${o.message}`);return a}async function c(e,t,r=5){try{let n=await o(e);return await i(n,r,t)}catch(e){return console.error("Embedding search failed:",e),s(t,r)}}},9313:(e,t,r)=>{r.d(t,{$3:()=>x,$L:()=>k,AF:()=>b,E5:()=>y,Kv:()=>o,ME:()=>A,RJ:()=>i,Rp:()=>v,TK:()=>f,W9:()=>m,Wl:()=>u,Yw:()=>$,_i:()=>a,fP:()=>h,hR:()=>w,iY:()=>F,ib:()=>E,kD:()=>c,km:()=>j,pj:()=>_,tR:()=>S,ty:()=>O,vr:()=>d,xJ:()=>l,yJ:()=>g,yW:()=>p,zE:()=>s,zx:()=>T});var n=r(964);async function a(){let{data:e,error:t}=await n.O.rpc("get_or_create_conversation");if(t)throw Error(`Failed to get/create conversation: ${t.message}`);return e}async function o(){let{error:e}=await n.O.rpc("close_old_conversations");if(e)throw Error(`Failed to close old conversations: ${e.message}`)}async function i(e){let{data:t,error:r}=await n.O.from("messages").select("*").eq("conversation_id",e).order("created_at",{ascending:!0});if(r)throw Error(`Failed to get messages: ${r.message}`);return t}async function s(e,t,r,a){let{data:o,error:i}=await n.O.from("messages").insert({conversation_id:e,role:t,content:r,active_context:a}).select().single();if(i)throw Error(`Failed to save message: ${i.message}`);return await n.O.from("conversations").update({last_activity:new Date().toISOString()}).eq("id",e),o}async function c(e){let{data:t,error:r}=await n.O.from("messages").select("active_context").eq("conversation_id",e).order("created_at",{ascending:!1}).limit(1).single();return r||!t?null:t.active_context}async function d(e){let{data:t,error:r}=await n.O.from("tasks").insert({description:e.description,project_id:e.project_id||null,deadline:e.deadline||null,priority:e.priority||"medium",is_recurring:e.is_recurring||!1,recurrence_rule:e.recurrence_rule||null}).select().single();if(r)throw Error(`Failed to create task: ${r.message}`);return t}async function l(e,t){let{data:r,error:a}=await n.O.from("tasks").update({...t,updated_at:new Date().toISOString()}).eq("id",e).select().single();if(a)throw Error(`Failed to update task: ${a.message}`);return r}async function u(e){let{data:t,error:r}=await n.O.from("tasks").update({status:"completed",completed_at:new Date().toISOString(),updated_at:new Date().toISOString()}).eq("id",e).select().single();if(r)throw Error(`Failed to complete task: ${r.message}`);return t}async function p(e){let{data:t,error:r}=await n.O.from("tasks").select("*").eq("id",e).single();return r?null:t}async function m(e){let{data:t,error:r}=await n.O.from("tasks").select("*").eq("project_id",e).neq("status","completed").order("created_at",{ascending:!1});if(r)throw Error(`Failed to get tasks: ${r.message}`);return t}async function f(){let{data:e,error:t}=await n.O.from("tasks").select("*").eq("status","pending").order("priority",{ascending:!1}).order("deadline",{ascending:!0});if(t)throw Error(`Failed to get pending tasks: ${t.message}`);return e}async function g(){let{data:e,error:t}=await n.O.from("tasks").select("*").eq("status","pending").lt("deadline",new Date().toISOString()).order("deadline",{ascending:!0});if(t)throw Error(`Failed to get overdue tasks: ${t.message}`);return e}async function w(){let e=new Date,t=new Date(e.setHours(0,0,0,0)).toISOString(),r=new Date(e.setHours(23,59,59,999)).toISOString(),{data:a,error:o}=await n.O.from("tasks").select("*").eq("status","pending").gte("deadline",t).lte("deadline",r).order("priority",{ascending:!1});if(o)throw Error(`Failed to get today's tasks: ${o.message}`);return a}async function h(){let e=new Date(Date.now()-864e5).toISOString(),{data:t,error:r}=await n.O.from("tasks").select("*").eq("status","pending").lt("deadline",new Date().toISOString()).or(`last_reminded_at.is.null,last_reminded_at.lt.${e}`).order("deadline",{ascending:!0});if(r)throw Error(`Failed to get tasks needing reminder: ${r.message}`);return t}async function _(e){let{error:t}=await n.O.from("tasks").update({last_reminded_at:new Date().toISOString()}).eq("id",e);if(t)throw Error(`Failed to update task reminder: ${t.message}`)}async function y(e){let{data:t,error:r}=await n.O.from("tasks").select("*").ilike("description",`%${e}%`).neq("status","completed").order("created_at",{ascending:!1}).limit(10);if(r)throw Error(`Failed to search tasks: ${r.message}`);return t}async function j(){let{data:e,error:t}=await n.O.from("tasks").select("*").neq("status","completed").order("created_at",{ascending:!1});if(t)throw Error(`Failed to get all tasks: ${t.message}`);return e}async function k(e){let{data:t,error:r}=await n.O.from("projects").insert({name:e.name,client_name:e.client_name||null,address:e.address||null,project_type:e.project_type||null,status:e.status||"future"}).select().single();if(r)throw Error(`Failed to create project: ${r.message}`);return t}async function O(e,t){let{data:r,error:a}=await n.O.from("projects").update({...t,updated_at:new Date().toISOString()}).eq("id",e).select().single();if(a)throw Error(`Failed to update project: ${a.message}`);return r}async function v(e){let{data:t,error:r}=await n.O.from("projects").select("*").eq("id",e).single();return r?null:t}async function E(e){let{data:t,error:r}=await n.O.from("projects").select("*").ilike("name",e).limit(1).single();return r?null:t}async function $(){let{data:e,error:t}=await n.O.from("projects").select("*").order("updated_at",{ascending:!1});if(t)throw Error(`Failed to get projects: ${t.message}`);return e}async function b(){let{data:e,error:t}=await n.O.from("projects").select("*").eq("status","active").order("updated_at",{ascending:!1});if(t)throw Error(`Failed to get active projects: ${t.message}`);return e}async function S(e){let{data:t,error:r}=await n.O.from("project_knowledge").insert({project_id:e.project_id||null,content:e.content,embedding:e.embedding,source_type:e.source_type,source_id:e.source_id||null}).select().single();if(r)throw Error(`Failed to add knowledge: ${r.message}`);return t}async function T(e){let{data:t,error:r}=await n.O.from("project_knowledge").select("*").eq("project_id",e).order("created_at",{ascending:!1});if(r)throw Error(`Failed to get project knowledge: ${r.message}`);return t}async function A(e){let{data:t,error:r}=await n.O.from("voice_transcripts").insert({raw_content:e.raw_content,duration_seconds:e.duration_seconds||null,source:e.source}).select().single();if(r)throw Error(`Failed to save transcript: ${r.message}`);return t}async function x(e,t){let{error:r}=await n.O.from("voice_transcripts").update({processed:!0,processed_at:new Date().toISOString(),processing_summary:t}).eq("id",e);if(r)throw Error(`Failed to update transcript: ${r.message}`)}async function F(e){let{data:t,error:r}=await n.O.from("daily_briefs").insert({brief_date:e.brief_date,content:e.content,tasks_included:e.tasks_included}).select().single();if(r)throw Error(`Failed to save daily brief: ${r.message}`);return t}},964:(e,t,r)=>{r.d(t,{O:()=>s});var n=r(7857);let a=process.env.SUPABASE_URL,o=process.env.SUPABASE_ANON_KEY,i=null,s=i=(0,n.eI)(a,o)},1931:(e,t,r)=>{r.d(t,{XZ:()=>s,aN:()=>d,fb:()=>c});let n=process.env.OPENROUTER_API_KEY,a=process.env.APP_URL||"https://patricks-assistant.vercel.app",o={FAST:"x-ai/grok-4.1-fast",SMART:"google/gemini-3-flash-preview"};async function i(e,t,r=3){let o=null;for(let i=0;i<r;i++)try{let r=await fetch("https://openrouter.ai/api/v1/chat/completions",{method:"POST",headers:{Authorization:`Bearer ${n}`,"Content-Type":"application/json","HTTP-Referer":a,"X-Title":"Patricks Assistant"},body:JSON.stringify({model:e,messages:t,temperature:.7})});if(!r.ok){let e=await r.text();throw Error(`OpenRouter API error: ${r.status} - ${e}`)}return(await r.json()).choices[0].message.content}catch(e){o=e,console.error(`Attempt ${i+1} failed:`,e),i<r-1&&await new Promise(e=>setTimeout(e,1e3*Math.pow(2,i)))}throw o||Error("Failed to call OpenRouter after retries")}async function s(e){return i(o.FAST,e)}async function c(e){return i(o.SMART,e)}async function d(e){let t=await s(e),r=t.match(/\{[\s\S]*\}/);if(!r)throw Error("No JSON found in response");try{return JSON.parse(r[0])}catch(e){throw Error(`Failed to parse JSON response: ${t}`)}}},2126:(e,t,r)=>{r.d(t,{_P:()=>p,_b:()=>c,bG:()=>s,kN:()=>u,mo:()=>m,zh:()=>d});let n=process.env.TELEGRAM_BOT_TOKEN,a=`https://api.telegram.org/bot${n}`,o=process.env.PATRICK_TELEGRAM_ID;async function i(e,t,r=3){let n=null;for(let o=0;o<r;o++)try{let r=await fetch(`${a}/${e}`,{method:"POST",headers:{"Content-Type":"application/json"},body:t?JSON.stringify(t):void 0}),n=await r.json();if(!n.ok)throw Error(`Telegram API error: ${n.description}`);return n.result}catch(e){n=e,console.error(`Telegram API attempt ${o+1} failed:`,e),o<r-1&&await new Promise(e=>setTimeout(e,1e3*Math.pow(2,o)))}throw n||Error("Failed to call Telegram API after retries")}async function s(e,t){await i("sendMessage",{chat_id:e,text:t,parse_mode:"HTML"})}async function c(e){await s(o,e)}async function d(e){await i("sendChatAction",{chat_id:e,action:"typing"})}async function l(e){return await i("getFile",{file_id:e})}async function u(e){let t=await l(e),r=`https://api.telegram.org/file/bot${n}/${t.file_path}`,a=await fetch(r);if(!a.ok)throw Error(`Failed to download voice note: ${a.status}`);let o=await a.arrayBuffer();return Buffer.from(o)}function p(e,t){return e===t}async function m(e){let t=`Your nephew Aidan failed to build me correctly. Blame him not me.

Context: ${e}`;await c(t)}}};var t=require("../../../../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),n=t.X(0,[276,564],()=>r(7130));module.exports=n})();